<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>InfiniteDraft</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        margin: 0;
        padding: 20px;
        background: #222;
        color: #eee;
      }
      header {
        background-color: #111;
        padding: 12px 16px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        border-bottom: 2px solid #444;
      }
      .header-left { flex: 1; text-align: left; }
      .header-center { flex: 1; text-align: center; }
      .header-right { flex: 1; text-align: right; }
      #pack-info { font-size: 16px; }
      #presence-info { font-size: 13px; color: #ccc; margin-left: 12px; }
      #waiting-msg { font-weight: bold; color: #ffcc00; display: none; }
      #image-container {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
        gap: 15px;
        justify-items: center;
        padding: 20px;
        z-index: 0;
        min-height: 240px;
      }
      .image-card { display:flex; flex-direction:column; align-items:center; cursor:pointer; width:100%; }
      img { width:100%; height:auto; object-fit:contain; background:#000; border-radius:8px; border:2px solid #444; padding:5px; transition:transform .2s; }
      img:hover { transform:scale(1.05); }
      .name { margin-top:8px; font-size:16px; font-weight:bold; color:#f0f0f0; text-align:center; }
      footer { position: fixed; bottom:0; left:0; right:0; background:#111; border-top:2px solid #444; padding:10px 20px; display:flex; gap:10px; max-height:140px; overflow-x:auto; overflow-y:hidden; }
      .deck-card { width:100px; flex-shrink:0; text-align:center; }
      .deck-card img { width:100%; border-radius:6px; border:1px solid #555; }
      .deck-card .name { font-size:12px; color:#f0f0f0; margin-top:3px; }
      .center-wait { display:flex; justify-content:center; align-items:center; height:100%; font-weight:bold; color:#ffcc00; font-size:18px; }
    </style>
  </head>
  <body>
    <header>
      <div class="header-left">
        <div id="pack-info">Round <span id="round-num">1</span> — Pack <span id="pack-num">1</span> / <span id="total-packs">0</span></div>
      </div>
      <div class="header-center">
        <div id="waiting-msg">Waiting on the next pack...</div>
      </div>
      <div class="header-right">
        <div id="presence-info"></div>
      </div>
    </header>

    <div id="image-container"></div>

    <footer id="deck-container"></footer>

    <script src="https://cdn.socket.io/4.5.3/socket.io.min.js"></script>
    <script>
      // PRESENCE_SERVER injected by Flask
      const PRESENCE_SERVER = "{{ PRESENCE_SERVER|e }}";

      let presenceSocket = null;
      let packs = [];
      // per-client deck for current player
      let deck = [];
      let currentPackIndex = 0;
      let currentRound = 0;
      let totalRounds = 1;

      // waiting state
      let isWaiting = false;
      let waitingOnIndex = null;

      function queryParam(name) {
        const params = new URLSearchParams(window.location.search);
        return params.has(name) ? params.get(name) : null;
      }

      async function loadPacks() {
        try {
          const res = await fetch(PRESENCE_SERVER + '/get_packs');
          const j = await res.json();
          packs = j.packs || [];
          if (typeof j.current_round !== 'undefined') currentRound = j.current_round;
          totalRounds = j.rounds || 1;
          if (currentPackIndex >= packs.length) currentPackIndex = 0;
          document.getElementById('total-packs').textContent = packs.length;
          document.getElementById('round-num').textContent = (currentRound + 1);
          renderPack();
          renderDeck();
        } catch (e) {
          console.error('Failed to get packs', e);
        }
      }

      function renderPack() {
        const container = document.getElementById('image-container');
        container.innerHTML = '';

        // If client is waiting for the next pack, do not show the current pack; show waiting message in center.
        if (isWaiting) {
          const div = document.createElement('div');
          div.className = 'center-wait';
          div.textContent = 'Waiting for the next pack...';
          container.appendChild(div);
          document.getElementById('waiting-msg').style.display = '';
          return;
        } else {
          document.getElementById('waiting-msg').style.display = 'none';
        }

        if (!packs || packs.length === 0) {
          document.getElementById('pack-num').textContent = '0';
          return;
        }
        document.getElementById('pack-num').textContent = currentPackIndex + 1;
        const pack = packs[currentPackIndex] || [];
        pack.forEach(card => {
          const div = document.createElement('div');
          div.className = 'image-card';
          const img = document.createElement('img');
          img.src = card.url;
          img.alt = card.name;
          const name = document.createElement('div');
          name.className = 'name';
          name.textContent = card.name;
          div.appendChild(img);
          div.appendChild(name);
          div.onclick = () => pickCard(card.name);
          container.appendChild(div);
        });
      }

      function renderDeck() {
        const footer = document.getElementById('deck-container');
        footer.innerHTML = '';
        if (!deck || deck.length === 0) {
          footer.innerHTML = '<em style="color:#bbb">No cards in your deck yet</em>';
          return;
        }
        deck.forEach(c => {
          const d = document.createElement('div');
          d.className = 'deck-card';
          const img = document.createElement('img'); img.src = c.url; img.alt = c.name;
          const nm = document.createElement('div'); nm.className = 'name'; nm.textContent = c.name;
          d.appendChild(img); d.appendChild(nm);
          footer.appendChild(d);
        });
      }

      async function pickCard(cardName) {
        // When picking, include both player's name and the card name and the round we believe we're in.
        const playerName = queryParam('name');
        if (!playerName) {
          alert('No player name present; please rejoin from the waiting room.');
          return;
        }

        // clear any previous waiting poll
        clearWaitPoll();

        try {
          const res = await fetch(PRESENCE_SERVER + '/click', {
            method: 'POST',
            headers: {'Content-Type':'application/json'},
            body: JSON.stringify({
              player: playerName,
              card: cardName,
              pack_index: currentPackIndex,
              round: currentRound
            })
          });
          const j = await res.json();
          if (!res.ok) {
            alert(j.error || 'error');
            return;
          }

          // server returns the player's deck
          if (j.deck) {
            deck = j.deck;
            renderDeck();
          }

          if (j.advanced) {
            // server allowed immediate advance
            currentPackIndex = j.next_pack_index;
            if (typeof j.current_round !== 'undefined') currentRound = j.current_round;
            isWaiting = false;
            waitingOnIndex = null;
            await loadPacks();
            document.getElementById('waiting-msg').style.display = 'none';
          } else {
            // must wait for next pack; hide current pack and show waiting message
            isWaiting = true;
            waitingOnIndex = j.waiting_on;
            document.getElementById('waiting-msg').style.display = '';
            startWaiting(waitingOnIndex);
          }
        } catch (e) {
          console.error(e);
        }
      }

      let waitPollHandle = null;
      function startWaiting(packIndex) {
        // We still use the polling fallback but also respond to real-time 'packs_update' events
        clearInterval(waitPollHandle);
        waitPollHandle = setInterval(async () => {
          try {
            const res = await fetch(PRESENCE_SERVER + '/get_packs');
            const j = await res.json();
            const ready = j.packs_ready || [];
            if (ready[packIndex]) {
              // attempt claim including player name and round
              const playerName = queryParam('name');
              const claimRes = await fetch(PRESENCE_SERVER + '/claim_pack', {
                method: 'POST',
                headers: {'Content-Type':'application/json'},
                body: JSON.stringify({ pack_index: packIndex, name: playerName, round: currentRound })
              });
              const cj = await claimRes.json();
              if (claimRes.ok && cj.ok) {
                // claim succeeded: set current pack to this index and stop waiting
                currentPackIndex = packIndex;
                isWaiting = false;
                waitingOnIndex = null;
                clearInterval(waitPollHandle);
                // update deck if returned
                if (cj.deck) {
                  deck = cj.deck;
                  renderDeck();
                } else {
                  // fetch deck if missing
                  await fetchDeck(playerName);
                }
                await loadPacks();
              } else {
                // claim failed: continue polling / wait for packs_update
                console.warn('claim failed', cj);
              }
            }
          } catch (e) {
            console.error('wait poll error', e);
          }
        }, 1000);
      }

      function clearWaitPoll() {
        if (waitPollHandle) {
          clearInterval(waitPollHandle);
          waitPollHandle = null;
        }
      }

      async function fetchDeck(name) {
        try {
          const res = await fetch(PRESENCE_SERVER + '/get_deck?name=' + encodeURIComponent(name));
          const j = await res.json();
          deck = j.deck || [];
          renderDeck();
        } catch (e) {
          console.error('failed to fetch deck', e);
        }
      }

      function connectPresence(name) {
        if (presenceSocket) return;
        presenceSocket = io(PRESENCE_SERVER + '?name=' + encodeURIComponent(name), { transports: ['websocket', 'polling'] });

        presenceSocket.on('user_count', n => {
          const el = document.getElementById('presence-info');
          el.textContent = `• ${n} user${n===1? '':'s'} connected`;
        });

        presenceSocket.on('packs_update', data => {
          // realtime notification: if we are waiting and our waiting pack became ready, try claiming proactively
          if (isWaiting && waitingOnIndex !== null && data && data.packs_ready && data.packs_ready[waitingOnIndex]) {
            (async () => {
              const playerName = queryParam('name');
              try {
                const claimRes = await fetch(PRESENCE_SERVER + '/claim_pack', {
                  method: 'POST',
                  headers: {'Content-Type':'application/json'},
                  body: JSON.stringify({ pack_index: waitingOnIndex, name: playerName, round: data.current_round })
                });
                const cj = await claimRes.json();
                if (claimRes.ok && cj.ok) {
                  currentPackIndex = waitingOnIndex;
                  isWaiting = false;
                  waitingOnIndex = null;
                  clearWaitPoll();
                  if (cj.deck) {
                    deck = cj.deck;
                    renderDeck();
                  } else {
                    await fetchDeck(playerName);
                  }
                  // Update authoritative state from the payload's snapshot if present
                  if (data && typeof data.current_round !== 'undefined') {
                    currentRound = data.current_round;
                    packs = data.packs || packs;
                    document.getElementById('total-packs').textContent = packs.length;
                    document.getElementById('round-num').textContent = (currentRound + 1);
                  }
                  await loadPacks();
                }
              } catch (e) {
                console.error('proactive claim error', e);
              }
            })();
          } else {
            // general update: honor authoritative snapshot in payload if present, then reload packs
            if (data && typeof data.current_round !== 'undefined') {
              currentRound = data.current_round;
              packs = data.packs || packs;
              document.getElementById('total-packs').textContent = packs.length;
              document.getElementById('round-num').textContent = (currentRound + 1);
            }
            loadPacks();
          }
        });

        presenceSocket.on('go', d => {
          if (d && typeof d.pack_index !== 'undefined') {
            currentPackIndex = d.pack_index;
          }
          // client assigned start: fetch deck for this player
          const nameParam = queryParam('name');
          if (nameParam) fetchDeck(nameParam);
          loadPacks();
        });

        presenceSocket.on('disconnect', () => {
          document.getElementById('presence-info').textContent = '';
        });
      }

      (function init() {
        const startParam = queryParam('start');
        const nameParam = queryParam('name');
        if (startParam !== null) {
          const parsed = parseInt(startParam, 10);
          if (!Number.isNaN(parsed)) currentPackIndex = parsed;
        } else {
          currentPackIndex = 0;
        }
        if (nameParam) {
          connectPresence(nameParam);
          // fetch player's deck on load/reconnect
          fetchDeck(nameParam);
        }
        loadPacks();
      })();

      window.addEventListener('beforeunload', () => { if (presenceSocket) presenceSocket.disconnect(); });
    </script>
  </body>
</html>