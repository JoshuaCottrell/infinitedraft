<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>InfiniteDraft</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        margin: 0;
        padding: 20px;
        background: #222;
        color: #eee;
      }
      header {
        background-color: #111;
        padding: 12px 16px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        border-bottom: 2px solid #444;
      }
      .header-left { flex: 1; text-align: left; }
      .header-center { flex: 1; text-align: center; }
      .header-right { flex: 1; text-align: right; }
      #pack-info { font-size: 16px; }
      #presence-info { font-size: 13px; color: #ccc; margin-left: 12px; }
      #waiting-msg { font-weight: bold; color: #ffcc00; display: none; }
      #image-container {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
        gap: 15px;
        justify-items: center;
        padding: 20px;
        z-index: 0;
      }
      .image-card { display:flex; flex-direction:column; align-items:center; cursor:pointer; width:100%; }
      img { width:100%; height:auto; object-fit:contain; background:#000; border-radius:8px; border:2px solid #444; padding:5px; transition:transform .2s; }
      img:hover { transform:scale(1.05); }
      .name { margin-top:8px; font-size:16px; font-weight:bold; color:#f0f0f0; text-align:center; }
      footer { position: fixed; bottom:0; left:0; right:0; background:#111; border-top:2px solid #444; padding:10px 20px; display:flex; gap:10px; max-height:140px; overflow-x:auto; overflow-y:hidden; }
      .deck-card { width:100px; flex-shrink:0; text-align:center; }
      .deck-card img { width:100%; border-radius:6px; border:1px solid #555; }
      .deck-card .name { font-size:12px; color:#f0f0f0; margin-top:3px; }
    </style>
  </head>
  <body>
    <header>
      <div class="header-left">
        <div id="pack-info">Round <span id="round-num">1</span> — Pack <span id="pack-num">1</span> / <span id="total-packs">0</span></div>
      </div>
      <div class="header-center">
        <div id="waiting-msg">Waiting on the next pack...</div>
      </div>
      <div class="header-right">
        <div id="presence-info"></div>
      </div>
    </header>

    <div id="image-container"></div>

    <footer id="deck-container"></footer>

    <script src="https://cdn.socket.io/4.5.3/socket.io.min.js"></script>
    <script>
      const PRESENCE_SERVER = 'http://localhost:5001';
      let presenceSocket = null;
      let packs = [];
      let deck = [];
      let currentPackIndex = 0;
      let currentRound = 0;
      let totalRounds = 1;

      function queryParam(name) {
        const params = new URLSearchParams(window.location.search);
        return params.has(name) ? params.get(name) : null;
      }

      async function loadPacks() {
        try {
          const res = await fetch('/get_packs');
          const j = await res.json();
          packs = j.packs || [];
          if (typeof j.current_round !== 'undefined') currentRound = j.current_round;
          totalRounds = j.rounds || 1;
          if (currentPackIndex >= packs.length) currentPackIndex = 0;
          document.getElementById('total-packs').textContent = packs.length;
          document.getElementById('round-num').textContent = (currentRound + 1);
          renderPack();
          renderDeck();
        } catch (e) {
          console.error('Failed to get packs', e);
        }
      }

      function renderPack() {
        const container = document.getElementById('image-container');
        container.innerHTML = '';
        if (!packs || packs.length === 0) {
          document.getElementById('pack-num').textContent = '0';
          return;
        }
        document.getElementById('pack-num').textContent = currentPackIndex + 1;
        const pack = packs[currentPackIndex] || [];
        pack.forEach(card => {
          const div = document.createElement('div');
          div.className = 'image-card';
          const img = document.createElement('img');
          img.src = card.url;
          img.alt = card.name;
          const name = document.createElement('div');
          name.className = 'name';
          name.textContent = card.name;
          div.appendChild(img);
          div.appendChild(name);
          div.onclick = () => pickCard(card.name);
          container.appendChild(div);
        });
      }

      function renderDeck() {
        const footer = document.getElementById('deck-container');
        footer.innerHTML = '';
        if (!deck || deck.length === 0) {
          footer.innerHTML = '<em style="color:#bbb">No cards in deck yet</em>';
          return;
        }
        deck.forEach(c => {
          const d = document.createElement('div');
          d.className = 'deck-card';
          const img = document.createElement('img'); img.src = c.url; img.alt = c.name;
          const nm = document.createElement('div'); nm.className = 'name'; nm.textContent = c.name;
          d.appendChild(img); d.appendChild(nm);
          footer.appendChild(d);
        });
      }

      async function pickCard(name) {
        hideWaitingMsg();
        try {
          const res = await fetch('/click', {
            method: 'POST',
            headers: {'Content-Type':'application/json'},
            body: JSON.stringify({ name, pack_index: currentPackIndex })
          });
          const j = await res.json();
          if (!res.ok) {
            alert(j.error || 'error');
            return;
          }

          if (j.deck) {
            deck = j.deck;
            renderDeck();
          }

          if (j.advanced) {
            currentPackIndex = j.next_pack_index;
            if (typeof j.current_round !== 'undefined') currentRound = j.current_round;
            await loadPacks();
            hideWaitingMsg();
          } else {
            // need to wait on j.waiting_on
            startWaiting(j.waiting_on);
          }
        } catch (e) {
          console.error(e);
        }
      }

      function showWaitingMsg() { document.getElementById('waiting-msg').style.display = ''; }
      function hideWaitingMsg() { document.getElementById('waiting-msg').style.display = 'none'; }

      let waitPollHandle = null;
      function startWaiting(packIndex) {
        showWaitingMsg();
        // rely on realtime 'packs_update' events, but also fallback to polling every 1s
        clearInterval(waitPollHandle);
        waitPollHandle = setInterval(async () => {
          try {
            // check readiness via /get_packs
            const res = await fetch('/get_packs');
            const j = await res.json();
            const ready = j.packs_ready || [];
            if (ready[packIndex]) {
              // attempt to claim
              const claimRes = await fetch('/claim_pack', {
                method: 'POST',
                headers: {'Content-Type':'application/json'},
                body: JSON.stringify({ pack_index: packIndex })
              });
              const cj = await claimRes.json();
              if (claimRes.ok && cj.ok) {
                currentPackIndex = packIndex;
                hideWaitingMsg();
                clearInterval(waitPollHandle);
                await loadPacks();
              } else {
                // continue waiting
                console.warn('claim failed', cj);
              }
            }
          } catch (e) {
            console.error('wait poll error', e);
          }
        }, 1000);
      }

      function clearWaitPoll() {
        if (waitPollHandle) {
          clearInterval(waitPollHandle);
          waitPollHandle = null;
        }
      }

      function connectPresence(name) {
        if (presenceSocket) return;
        presenceSocket = io(PRESENCE_SERVER + '?name=' + encodeURIComponent(name), { transports: ['websocket', 'polling'] });

        presenceSocket.on('user_count', n => {
          const el = document.getElementById('presence-info');
          el.textContent = `• ${n} user${n===1? '':'s'} connected`;
        });

        presenceSocket.on('packs_update', data => {
          // receive realtime notification from app via presence server
          // simply reload current packs to sync state
          console.log('packs_update', data);
          // If waiting on a pack and data indicates it's ready, immediately attempt to claim
          if (data && typeof data.packs_ready !== 'undefined') {
            // if the pack we're waiting on became ready, claim immediately by letting startWaiting's poll detect it,
            // or we can proactively attempt claim. We'll proactively attempt claim if waiting.
            // (To keep simple, just reload packs)
            loadPacks();
          } else {
            loadPacks();
          }
        });

        presenceSocket.on('go', d => {
          // go event for this client includes pack_index and name
          if (d && typeof d.pack_index !== 'undefined') {
            currentPackIndex = d.pack_index;
          }
          loadPacks();
        });

        presenceSocket.on('disconnect', () => {
          document.getElementById('presence-info').textContent = '';
        });
      }

      // initialize: read start and name params from URL (provided by waiting room redirect)
      (function init() {
        const startParam = queryParam('start');
        const nameParam = queryParam('name');
        if (startParam !== null) {
          const parsed = parseInt(startParam, 10);
          if (!Number.isNaN(parsed)) currentPackIndex = parsed;
        } else {
          currentPackIndex = 0;
        }
        if (nameParam) connectPresence(nameParam);
        loadPacks();
      })();

      window.addEventListener('beforeunload', () => { if (presenceSocket) presenceSocket.disconnect(); });
    </script>
  </body>
</html>